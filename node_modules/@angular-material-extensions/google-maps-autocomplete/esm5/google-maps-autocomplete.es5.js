import { isPlatformBrowser, CommonModule } from '@angular/common';
import { Directive, forwardRef, Component, NgZone, ViewChild, Input, Output, EventEmitter, Inject, PLATFORM_ID, ElementRef, NgModule } from '@angular/core';
import { NG_VALIDATORS, FormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MapsAPILoader } from '@agm/core';
import { MatInputModule } from '@angular/material';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts
var MatValidateAddressDirective = /** @class */ (function () {
    function MatValidateAddressDirective() {
    }
    /**
     * @return {?}
     */
    MatValidateAddressDirective.prototype.validate = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            return _this.address ? null : {
                validateAddress: {
                    valid: false
                }
            };
        });
    };
    /**
     * @param {?} eventEmitter
     * @return {?}
     */
    MatValidateAddressDirective.prototype.subscribe = /**
     * @param {?} eventEmitter
     * @return {?}
     */
    function (eventEmitter) {
        var _this = this;
        this.subscription = eventEmitter.subscribe((/**
         * @param {?} address
         * @return {?}
         */
        function (address) {
            _this.address = address;
        }));
    };
    /**
     * @return {?}
     */
    MatValidateAddressDirective.prototype.unsubscribe = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    Object.defineProperty(MatValidateAddressDirective.prototype, "address", {
        get: /**
         * @return {?}
         */
        function () {
            return this._address;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._address = value;
        },
        enumerable: true,
        configurable: true
    });
    MatValidateAddressDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',
                    providers: [
                        { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return MatValidateAddressDirective; })), multi: true }
                    ]
                },] },
    ];
    /** @nocollapse */
    MatValidateAddressDirective.ctorParameters = function () { return []; };
    return MatValidateAddressDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var Appearance = {
    STANDARD: 'standard',
    FILL: 'fill',
    OUTLINE: 'outline',
    LEGACY: 'legacy',
};
var MatGoogleMapsAutocompleteComponent = /** @class */ (function () {
    function MatGoogleMapsAutocompleteComponent(_mapsAPILoader, _ngZone) {
        this._mapsAPILoader = _mapsAPILoader;
        this._ngZone = _ngZone;
        this.addressLabelText = 'Address';
        this.placeholderText = 'Please enter the address';
        this.requiredErrorText = 'The address is required';
        this.invalidErrorText = 'The address is not valid';
        this.appearance = Appearance.STANDARD;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
    }
    /**
     * @return {?}
     */
    MatGoogleMapsAutocompleteComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        /** @type {?} */
        var options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    };
    /**
     * @return {?}
     */
    MatGoogleMapsAutocompleteComponent.prototype.initGoogleMapsAutocomplete = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._mapsAPILoader
            .load()
            .then((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var autocomplete = new google.maps.places.Autocomplete(_this.searchElementRef.nativeElement, _this.autoCompleteOptions);
            autocomplete.addListener('place_changed', (/**
             * @return {?}
             */
            function () {
                _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    // get the place result
                    /** @type {?} */
                    var place = autocomplete.getPlace();
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    _this.address = place.formatted_address;
                    _this.onAutocompleteSelected.emit(place);
                    // console.log('onAutocompleteSelected -> ', place);
                    _this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                }));
            }));
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return console.log(err); }));
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatGoogleMapsAutocompleteComponent.prototype.onQuery = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('onChange()', event);
        this.onChange.emit(this.address);
    };
    /**
     * @private
     * @return {?}
     */
    MatGoogleMapsAutocompleteComponent.prototype.resetAddress = /**
     * @private
     * @return {?}
     */
    function () {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    };
    MatGoogleMapsAutocompleteComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mat-google-maps-autocomplete',
                    exportAs: 'matGoogleMapsAutocomplete',
                    template: "\n    <mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n      <mat-label>{{addressLabelText}}</mat-label>\n      <input matInput\n             [(ngModel)]=\"address\"\n             (change)=\"onQuery($event)\"\n             placeholder=\"{{placeholderText}}\"\n             class=\"form-control\"\n             #search\n             MatValidateAddress\n             required>\n      <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n        {{requiredErrorText}}\n      </mat-error>\n      <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n        {{invalidErrorText}}\n      </mat-error>\n    </mat-form-field>\n  ",
                    styles: ["\n    .full-width{width:100%}\n  "]
                },] },
    ];
    /** @nocollapse */
    MatGoogleMapsAutocompleteComponent.ctorParameters = function () { return [
        { type: MapsAPILoader },
        { type: NgZone }
    ]; };
    MatGoogleMapsAutocompleteComponent.propDecorators = {
        searchElementRef: [{ type: ViewChild, args: ['search', { static: false },] }],
        addressLabelText: [{ type: Input }],
        placeholderText: [{ type: Input }],
        requiredErrorText: [{ type: Input }],
        invalidErrorText: [{ type: Input }],
        appearance: [{ type: Input }],
        address: [{ type: Input }],
        country: [{ type: Input }],
        placeIdOnly: [{ type: Input }],
        strictBounds: [{ type: Input }],
        types: [{ type: Input }],
        type: [{ type: Input }],
        autoCompleteOptions: [{ type: Input }],
        onChange: [{ type: Output }],
        onAutocompleteSelected: [{ type: Output }],
        onLocationSelected: [{ type: Output }]
    };
    return MatGoogleMapsAutocompleteComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatGoogleMapsAutocompleteDirective = /** @class */ (function () {
    function MatGoogleMapsAutocompleteDirective(platformId, elemRef, mapsAPILoader, _ngZone) {
        this.platformId = platformId;
        this.elemRef = elemRef;
        this.mapsAPILoader = mapsAPILoader;
        this._ngZone = _ngZone;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
    }
    /**
     * @return {?}
     */
    MatGoogleMapsAutocompleteDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (isPlatformBrowser(this.platformId)) {
            this.addressValidator.subscribe(this.onNewPlaceResult);
            /** @type {?} */
            var options = {
                // types: ['address'],
                // componentRestrictions: {country: this.country},
                placeIdOnly: this.placeIdOnly,
                strictBounds: this.strictBounds,
                // types: this.types,
                type: this.type
            };
            // tslint:disable-next-line:no-unused-expression
            this.country ? options.componentRestrictions = { country: this.country } : null;
            // tslint:disable-next-line:no-unused-expression
            this.country ? options.types = this.types : null;
            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
            this.initGoogleMapsAutocomplete();
        }
    };
    /**
     * @return {?}
     */
    MatGoogleMapsAutocompleteDirective.prototype.initGoogleMapsAutocomplete = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mapsAPILoader
            .load()
            .then((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var autocomplete = new google.maps.places.Autocomplete(_this.elemRef.nativeElement, _this.autoCompleteOptions);
            autocomplete.addListener('place_changed', (/**
             * @return {?}
             */
            function () {
                _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    // get the place result
                    /** @type {?} */
                    var place = autocomplete.getPlace();
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    _this.address = place.formatted_address;
                    _this.onAutocompleteSelected.emit(place);
                    _this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                }));
            }));
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return console.log(err); }));
    };
    MatGoogleMapsAutocompleteDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[matGoogleMapsAutocomplete]',
                    exportAs: 'matGoogleMapsAutocomplete',
                },] },
    ];
    /** @nocollapse */
    MatGoogleMapsAutocompleteDirective.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: ElementRef },
        { type: MapsAPILoader },
        { type: NgZone }
    ]; };
    MatGoogleMapsAutocompleteDirective.propDecorators = {
        address: [{ type: Input }],
        country: [{ type: Input }],
        placeIdOnly: [{ type: Input }],
        strictBounds: [{ type: Input }],
        types: [{ type: Input }],
        type: [{ type: Input }],
        autoCompleteOptions: [{ type: Input }],
        onChange: [{ type: Output }],
        onAutocompleteSelected: [{ type: Output }],
        onLocationSelected: [{ type: Output }]
    };
    return MatGoogleMapsAutocompleteDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatGoogleMapsAutocompleteModule = /** @class */ (function () {
    function MatGoogleMapsAutocompleteModule() {
    }
    /**
     * @return {?}
     */
    MatGoogleMapsAutocompleteModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: MatGoogleMapsAutocompleteModule,
            providers: []
        };
    };
    MatGoogleMapsAutocompleteModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatInputModule
                    ],
                    exports: [
                        MatGoogleMapsAutocompleteComponent,
                        MatGoogleMapsAutocompleteDirective,
                        MatValidateAddressDirective
                    ],
                    declarations: [
                        MatGoogleMapsAutocompleteComponent,
                        MatGoogleMapsAutocompleteDirective,
                        MatValidateAddressDirective
                    ]
                },] },
    ];
    return MatGoogleMapsAutocompleteModule;
}());

export { Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatValidateAddressDirective };
//# sourceMappingURL=google-maps-autocomplete.es5.js.map
