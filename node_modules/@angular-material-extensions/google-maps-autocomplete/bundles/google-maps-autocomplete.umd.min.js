!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/common"),require("@angular/core"),require("@angular/forms"),require("@agm/core"),require("@angular/material")):"function"==typeof define&&define.amd?define(["exports","@angular/common","@angular/core","@angular/forms","@agm/core","@angular/material"],t):t((e=e||self).angularMaterialExtensionsGoogleMapsAutocomplete={},e.ng.common,e.ng.core,e.ng.forms,e.agmCore,e.ng.material)}(this,function(e,t,o,n,r,a){"use strict";var s=function(){function e(){}return e.prototype.validate=function(){var e=this;return function(t){return e.address?null:{validateAddress:{valid:!1}}}},e.prototype.subscribe=function(e){var t=this;this.subscription=e.subscribe(function(e){t.address=e})},e.prototype.unsubscribe=function(){this.subscription.unsubscribe()},Object.defineProperty(e.prototype,"address",{get:function(){return this._address},set:function(e){this._address=e},enumerable:!0,configurable:!0}),e.decorators=[{type:o.Directive,args:[{selector:"[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]",providers:[{provide:n.NG_VALIDATORS,useExisting:o.forwardRef(function(){return e}),multi:!0}]}]}],e.ctorParameters=function(){return[]},e}(),i={STANDARD:"standard",FILL:"fill",OUTLINE:"outline",LEGACY:"legacy"},l=function(){function e(e,t){this._mapsAPILoader=e,this._ngZone=t,this.addressLabelText="Address",this.placeholderText="Please enter the address",this.requiredErrorText="The address is required",this.invalidErrorText="The address is not valid",this.appearance=i.STANDARD,this.autoCompleteOptions={},this.onChange=new o.EventEmitter,this.onAutocompleteSelected=new o.EventEmitter,this.onLocationSelected=new o.EventEmitter,this.onNewPlaceResult=new o.EventEmitter,this.addressValidator=new s,this.addressSearchControl=new n.FormControl({value:null},n.Validators.compose([n.Validators.required,this.addressValidator.validate()]))}return e.prototype.ngOnInit=function(){this.addressValidator.subscribe(this.onNewPlaceResult);var e={placeIdOnly:this.placeIdOnly,strictBounds:this.strictBounds,type:this.type};this.country&&(e.componentRestrictions={country:this.country}),this.country&&(e.types=this.types),this.autoCompleteOptions=Object.assign(this.autoCompleteOptions,e),this.initGoogleMapsAutocomplete()},e.prototype.initGoogleMapsAutocomplete=function(){var e=this;this._mapsAPILoader.load().then(function(){var t=new google.maps.places.Autocomplete(e.searchElementRef.nativeElement,e.autoCompleteOptions);t.addListener("place_changed",function(){e._ngZone.run(function(){var o=t.getPlace();o.place_id&&void 0!==o.geometry&&null!==o.geometry&&(e.address=o.formatted_address,e.onAutocompleteSelected.emit(o),e.onLocationSelected.emit({latitude:o.geometry.location.lat(),longitude:o.geometry.location.lng()}))})})}).catch(function(e){return console.log(e)})},e.prototype.onQuery=function(e){this.onChange.emit(this.address)},e.prototype.resetAddress=function(){this.address=null,this.addressSearchControl.updateValueAndValidity()},e.decorators=[{type:o.Component,args:[{selector:"mat-google-maps-autocomplete",exportAs:"matGoogleMapsAutocomplete",template:'\n    <mat-form-field class="full-width" [appearance]="appearance">\n      <mat-label>{{addressLabelText}}</mat-label>\n      <input matInput\n             [(ngModel)]="address"\n             (change)="onQuery($event)"\n             placeholder="{{placeholderText}}"\n             class="form-control"\n             #search\n             MatValidateAddress\n             required>\n      <mat-error *ngIf="addressSearchControl.hasError(\'required\')">\n        {{requiredErrorText}}\n      </mat-error>\n      <mat-error *ngIf="addressSearchControl.hasError(\'validateAddress\')">\n        {{invalidErrorText}}\n      </mat-error>\n    </mat-form-field>\n  ',styles:["\n    .full-width{width:100%}\n  "]}]}],e.ctorParameters=function(){return[{type:r.MapsAPILoader},{type:o.NgZone}]},e.propDecorators={searchElementRef:[{type:o.ViewChild,args:["search",{static:!1}]}],addressLabelText:[{type:o.Input}],placeholderText:[{type:o.Input}],requiredErrorText:[{type:o.Input}],invalidErrorText:[{type:o.Input}],appearance:[{type:o.Input}],address:[{type:o.Input}],country:[{type:o.Input}],placeIdOnly:[{type:o.Input}],strictBounds:[{type:o.Input}],types:[{type:o.Input}],type:[{type:o.Input}],autoCompleteOptions:[{type:o.Input}],onChange:[{type:o.Output}],onAutocompleteSelected:[{type:o.Output}],onLocationSelected:[{type:o.Output}]},e}(),p=function(){function e(e,t,r,a){this.platformId=e,this.elemRef=t,this.mapsAPILoader=r,this._ngZone=a,this.autoCompleteOptions={},this.onChange=new o.EventEmitter,this.onAutocompleteSelected=new o.EventEmitter,this.onLocationSelected=new o.EventEmitter,this.onNewPlaceResult=new o.EventEmitter,this.addressValidator=new s,this.addressSearchControl=new n.FormControl({value:null},n.Validators.compose([n.Validators.required,this.addressValidator.validate()]))}return e.prototype.ngOnInit=function(){if(t.isPlatformBrowser(this.platformId)){this.addressValidator.subscribe(this.onNewPlaceResult);var e={placeIdOnly:this.placeIdOnly,strictBounds:this.strictBounds,type:this.type};this.country&&(e.componentRestrictions={country:this.country}),this.country&&(e.types=this.types),this.autoCompleteOptions=Object.assign(this.autoCompleteOptions,e),this.initGoogleMapsAutocomplete()}},e.prototype.initGoogleMapsAutocomplete=function(){var e=this;this.mapsAPILoader.load().then(function(){var t=new google.maps.places.Autocomplete(e.elemRef.nativeElement,e.autoCompleteOptions);t.addListener("place_changed",function(){e._ngZone.run(function(){var o=t.getPlace();o.place_id&&void 0!==o.geometry&&null!==o.geometry&&(e.address=o.formatted_address,e.onAutocompleteSelected.emit(o),e.onLocationSelected.emit({latitude:o.geometry.location.lat(),longitude:o.geometry.location.lng()}))})})}).catch(function(e){return console.log(e)})},e.decorators=[{type:o.Directive,args:[{selector:"[matGoogleMapsAutocomplete]",exportAs:"matGoogleMapsAutocomplete"}]}],e.ctorParameters=function(){return[{type:String,decorators:[{type:o.Inject,args:[o.PLATFORM_ID]}]},{type:o.ElementRef},{type:r.MapsAPILoader},{type:o.NgZone}]},e.propDecorators={address:[{type:o.Input}],country:[{type:o.Input}],placeIdOnly:[{type:o.Input}],strictBounds:[{type:o.Input}],types:[{type:o.Input}],type:[{type:o.Input}],autoCompleteOptions:[{type:o.Input}],onChange:[{type:o.Output}],onAutocompleteSelected:[{type:o.Output}],onLocationSelected:[{type:o.Output}]},e}(),d=function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:o.NgModule,args:[{imports:[t.CommonModule,n.FormsModule,n.ReactiveFormsModule,a.MatInputModule],exports:[l,p,s],declarations:[l,p,s]}]}],e}();e.Appearance=i,e.MatGoogleMapsAutocompleteComponent=l,e.MatGoogleMapsAutocompleteDirective=p,e.MatGoogleMapsAutocompleteModule=d,e.MatValidateAddressDirective=s,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=google-maps-autocomplete.umd.min.js.map
